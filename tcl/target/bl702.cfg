# SPDX-License-Identifier: GPL-2.0-or-later

#
# Bouffalo Labs BL702, BL704 and BL706 target
#
# https://en.bouffalolab.com/product/?type=detail&id=8
#
# Default JTAG pins: (if not changed by eFuse configuration)
# TMS - GPIO0
# TDI - GPIO1
# TCK - GPIO2
# TDO - GPIO9
#

source [find mem_helper.tcl]

transport select jtag

if { [info exists CHIPNAME] } {
	set _CHIPNAME $CHIPNAME
} else {
	set _CHIPNAME bl702
}

jtag newtap $_CHIPNAME cpu -irlen 5 -expected-id 0x20000e05

set _TARGETNAME $_CHIPNAME.cpu
target create $_TARGETNAME riscv -chain-position $_TARGETNAME

riscv set_mem_access sysbus

$_TARGETNAME configure -work-area-phys 0x22014000 -work-area-size 0xC000 -work-area-backup 1

# Internal RC ticks on 32 MHz, so this speed should be safe to use.
adapter speed 8000

set _FLASHNAME $_CHIPNAME.flash
flash bank $_FLASHNAME bl602_flash 0x23000000 0 0 0 $_TARGETNAME

$_TARGETNAME configure -event reset-init {
#	echo "Reset init!"
	flash probe 0
}

# ndmreset resets only Trust Zone Controller, so we need to do SW reset instead.
# $_TARGETNAME configure -event reset-assert-pre {
# 	halt
# 
# 	# Switch clock to internal RC32M
# 	# In HBN_GLB, set ROOT_CLK_SEL = 0
# 	mmw 0x4000f030 0x0 0x00000003
# 	# Wait for clock switch
# 	sleep 10
# 
# 	# GLB_REG_BCLK_DIS_FALSE
# 	mww 0x40000ffc 0x0
# 
# 	# HCLK is RC32M, so BCLK/HCLK doesn't need divider
# 	# In GLB_CLK_CFG0, set BCLK_DIV = 0 and HCLK_DIV = 0
# 	mmw 0x40000000 0x0 0x00FFFF00
# 	# Wait for clock to stabilize
# 	sleep 10
# 
# 	# Do reset
# 	# In GLB_SWRST_CFG2, clear CTRL_SYS_RESET, CTRL_CPU_RESET and CTRL_PWRON_RESET
# 	mmw 0x40000018 0x0 0x00000007
# 	# In GLB_SWRST_CFG2, set CTRL_SYS_RESET, CTRL_CPU_RESET and CTRL_PWRON_RESET to 1
# 	# mww 0x40000014 0xFFFFFFFF 0x0
# 	riscv set_mem_access abstract
# 	mww 0x40000018 0x7 0x0
# 	riscv set_mem_access sysbus
# 
# 	# GPIO reset
# 
# 	write_memory 0x22014000 32 { 0x0005a303 0xff800393 0x00737333 0x0065a023 0x00700313 0x0065a023  }
# 	reg a1 0x40000018
# 	reg pc 0x22014000
# 	resume
# }


#$_TARGETNAME configure -event reset-assert {
#	set dmcontrol 		0x10
#	set dmcontrol_dmactive	[expr {1 << 0}]
#	set dmcontrol_ackhavereset [expr {1 << 28}]
#	set dmcontrol_haltreq	[expr {1 << 31}]
#
#	global _RESETMODE
#
#	# If hardware NRST signal is connected and configured (reset_config srst_only)
#	# the device has been recently reset in 'jtag arp_init-reset', therefore
#	# DM_DMSTATUS_ANYHAVERESET reads 1.
#	# The following 'halt' command checks this status bit
#	# and shows 'Hart 0 unexpectedly reset!' if set.
#	# Prevent this message by sending an acknowledge first.
#	set val [expr {$dmcontrol_dmactive | $dmcontrol_ackhavereset}]
#	riscv dmi_write $dmcontrol $val
#
#	# Halt the core so that we can write to memory. We do this first so
#	# that it doesn't clobber our dmcontrol configuration.
#	halt
#
#	# Set haltreq appropriately for the type of reset we're doing. This
#	# replicates what the generic RISC-V reset_assert() function would
#	# do if we weren't overriding it. The $_RESETMODE hack sucks, but
#	# it's the least invasive way to determine whether we need to halt.
#	#
#	# If we didn't override the generic handler, we'd actually still have
#	# to do this: the default handler sets ndmreset, which prevents memory
#	# access even though it doesn't actually trigger a reset on this chip.
#	# So we'd need to unset it here, which involves a write to dmcontrol,
#	# Since haltreq is write-only and there's no way to leave it unchanged,
#	# we'd have to figure out its proper value anyway.
#	set val $dmcontrol_dmactive
#	if {$_RESETMODE ne "run"} {
#		set val [expr {$val | $dmcontrol_haltreq}]
#	}
#	riscv dmi_write $dmcontrol $val
#
# 	# Switch clock to internal RC32M
# 	# In HBN_GLB, set ROOT_CLK_SEL = 0
# 	mmw 0x4000f030 0x0 0x00000003
# 	# Wait for clock switch
# 	sleep 10
# 
# 	# GLB_REG_BCLK_DIS_FALSE
# 	mww 0x40000ffc 0x0
# 
# 	# HCLK is RC32M, so BCLK/HCLK doesn't need divider
# 	# In GLB_CLK_CFG0, set BCLK_DIV = 0 and HCLK_DIV = 0
# 	mmw 0x40000000 0x0 0x00FFFF00
# 	# Wait for clock to stabilize
# 	sleep 10
# 
# 	# Do reset
# 	# In GLB_SWRST_CFG2, clear CTRL_SYS_RESET, CTRL_CPU_RESET and CTRL_PWRON_RESET
# 	mmw 0x40000018 0x0 0x00000007
#
#	# We need to trigger the reset using abstract memory access, since
#	# progbuf access tries to read a status code out of a core register
#	# after the write happens, which fails when the core is in reset.
#
#	# Go!
# 	# In GLB_SWRST_CFG2, set CTRL_SYS_RESET, CTRL_CPU_RESET and CTRL_PWRON_RESET to 1
#	echo "Lets go!"
# 	# mww 0x40000018 0x7
#	write_memory 0x22014000 32 { 0x0005a303 0xff800393 0x00737333 0x0065a023 0x00700313 0x0065a023  }
#	reg a1 0x40000018
#	reg pc 0x22014000
#	resume
#
#	# Put the memory access mode back to what it was.
#}

$_TARGETNAME configure -event reset-assert-post {
	echo "meow"
	# Switch clock to internal RC32M
 	# In HBN_GLB, set ROOT_CLK_SEL = 0
 	mmw 0x4000f030 0x0 0x00000003
 	# Wait for clock switch
 	sleep 10
 
 	# GLB_REG_BCLK_DIS_FALSE
 	mww 0x40000ffc 0x0
 
 	# HCLK is RC32M, so BCLK/HCLK doesn't need divider
 	# In GLB_CLK_CFG0, set BCLK_DIV = 0 and HCLK_DIV = 0
 	mmw 0x40000000 0x0 0x00FFFF00
 	# Wait for clock to stabilize
 	sleep 10
 
 	# Do reset
 	# In GLB_SWRST_CFG2, clear CTRL_SYS_RESET, CTRL_CPU_RESET and CTRL_PWRON_RESET
 	mmw 0x40000018 0x0 0x00000007

	# We need to trigger the reset using abstract memory access, since
	# progbuf access tries to read a status code out of a core register
	# after the write happens, which fails when the core is in reset.

	# Go!
 	# In GLB_SWRST_CFG2, set CTRL_SYS_RESET, CTRL_CPU_RESET and CTRL_PWRON_RESET to 1
	echo "Lets go!"
 	# mww 0x40000018 0x7
	write_memory 0x22014000 32 { 0x0005a303 0xff800393 0x00737333 0x0065a023 0x00700313 0x0065a023  }
	reg a1 0x40000018
	reg pc 0x22014000
	resume
}


# Capture the mode of a given reset so that we can use it later in the
# reset-assert handler.
proc init_reset { mode } {
	global _RESETMODE
	set _RESETMODE $mode

	if {[using_jtag]} {
		jtag arp_init-reset
	}
}
